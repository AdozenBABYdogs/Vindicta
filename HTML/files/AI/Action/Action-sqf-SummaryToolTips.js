NDSummary.OnToolTipsLoaded("File:AI/Action/Action.sqf",{236:"<div class=\"NDToolTip TClass LSQF\"><div class=\"TTSummary\">Action represents something which an agent can do over some period of time.&nbsp; Action can be in many states, see ACTION_STATE.</div></div>",254:"<div class=\"NDToolTip TVariable LSQF\"><div class=\"TTSummary\">Holds a reference to AI object which owns this action</div></div>",255:"<div class=\"NDToolTip TVariable LSQF\"><div class=\"TTSummary\">State of this action. Can be one of ACTION_STATE</div></div>",256:"<div class=\"NDToolTip TVariable LSQF\"><div class=\"TTSummary\">holds a reference to timer which sends PROCESS messages to this Action, if it\'s autonomous</div></div>",242:"<div class=\"NDToolTip TFunction LSQF\"><div class=\"TTSummary\">Creates this action.</div></div>",244:"<div class=\"NDToolTip TFunction LSQF\"><div class=\"TTSummary\">Sets the goal to autonomous mode.&nbsp; Autonomous goals have a timer which generate a message to call the goal\'s process method.&nbsp; By default actions are processed in the process method of their AI (&lt;AI.process&gt;).</div></div>",245:"<div class=\"NDToolTip TFunction LSQF\"><div class=\"TTSummary\">See MessageReceiver.handleMessage.</div></div>",257:"<div class=\"NDToolTip TFunction LSQF\"><div class=\"TTSummary\">Calls the Activate method of this action if it\'s inactive.</div></div>",258:"<div class=\"NDToolTip TFunction LSQF\"><div class=\"TTSummary\">Calls the Activate method of this action if it\'s in failed state.</div></div>",259:"<div class=\"NDToolTip TFunction LSQF\"><div class=\"TTSummary\">logic to run when the goal is activated</div></div>",260:"<div class=\"NDToolTip TFunction LSQF\"><div class=\"TTSummary\">logic to run each update-step</div></div>",261:"<div class=\"NDToolTip TFunction LSQF\"><div class=\"TTSummary\">logic to run when the goal is satisfied, or before it is deleted.</div></div>",262:"<div class=\"NDToolTip TFunction LSQF\"><div class=\"TTSummary\">an Action is atomic and cannot aggregate subactions yet we must implement this method to provide the uniform interface required for the action hierarchy.</div></div>",263:"<div class=\"NDToolTip TFunction LSQF\"><div class=\"TTSummary\">an Action is atomic and cannot aggregate subactions yet we must implement this method to provide the uniform interface required for the action hierarchy.</div></div>",264:"<div class=\"NDToolTip TFunction LSQF\"><div class=\"TTSummary\">Returns the list of subactions (for debug purposes).</div></div>",265:"<div class=\"NDToolTip TFunction LSQF\"><div class=\"TTSummary\">Returns: true if action is in completed state, false otherwise</div></div>",266:"<div class=\"NDToolTip TFunction LSQF\"><div class=\"TTSummary\">Returns: true if action is in active state, false otherwise</div></div>",267:"<div class=\"NDToolTip TFunction LSQF\"><div class=\"TTSummary\">Returns: true if action is in inactive state, false otherwise</div></div>",268:"<div class=\"NDToolTip TFunction LSQF\"><div class=\"TTSummary\">Returns: true if action is in failed state, false otherwise</div></div>",269:"<div class=\"NDToolTip TFunction LSQF\"><div class=\"TTSummary\">Returns the cost of taking this action in current situation By default it returns the value of &quot;cost&quot; static variable You can redefine it for inherited action if the returned cost needs to depend on something</div></div>",270:"<div class=\"NDToolTip TFunction LSQF\"><div class=\"TTSummary\">Returns preconditions of this action depending on parameters By default it tries to apply parameters to preconditions, if preconditions reference any parameters</div></div>"});